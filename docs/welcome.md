---
sidebar_position: 2
title: "Finally, Welcome"
---
## Some Context

Hello!

This documentation is an effort to ease the pain of learning &mdash; and recalling &mdash; the details of Haskell that is conducive to my way of thinking.

Part of my own challenge, I'm sure, that while I'm no stranger to functional programming, Haskell is abyssal to the degree at which it approaches the topic. The last major release of Haskell was July of 2010, fourteen years ago as of this writing. For a language that has been around for as long as it has and is as deeply rooted in academia (or perhaps because of!), documentation is often (in my mind) inconsistent, incomplete, or downright opaque.

The world of Haskell is... _dilatory_ to say the least. You'll regularly find that your internet searches will come up with articles date 5 or 10 or more years old on topics that you'd expect there to be more up-to-date answers to. At first glance, it almost seems like Haskell came to a stop a decade ago.

Likewise, libraries and code samples are often wildly out of date... running sample code from books or from GitHub can take a bit of effort to untangle and get all of the version numbers properly aligned. While [Hackage](https://hackage.haskell.org/) is the main authority on the matter, I've found it fails to provide clarity on the current _usefulness_ of a given package (and I've read that there are innumerable "test" and unsupported packages that clog up the system).

There is, of course, a modern and active community ([r/haskell](https://www.reddit.com/r/haskell/) has been kind to me) and while the official language hasn't been updated in fourteen years, the complier is kept up to date and there are many extensions and tools that have been added on to help modernize the developer experience (to a point... my experience with the Haskell Language Server has been a nightmare, slowing my development process down to a glacial pace).

So yes, Haskell is far from a dead language. The likes of Facebook and Google have dabbled in it and I'm aware of several modern, well-funded companies who use the language as their principal backend development choice. But the documentation and support that you'd find in a typical modern language is lacking to say the least. 

This is my effort to add to the panoply of documentation, but hopefully with a different enough approach that it might help someone other than myself.

## Other Resources

### My Favorites
So far, these three sources have been my favorite for learning Haskell and I return to them on a regular basis:
- [Learn You a Haskell](https://learnyouahaskell.com/) (LYAH) &mdash; Beginner course; sometimes a little too silly and verbose, but probably the most grounded in terms of providing solid explanations for some of the more complex ideas in Haskell.
- [Haskell MOOC](https://haskell.mooc.fi/) &mdash; Short online course from the University of Helsinki. Well-ordered, succinct, linear, and importantly, clear. The examples are non-trivial and interesting.
- [Well-Typed Intro to Haskell](https://www.youtube.com/watch?v=3blAsQDT0u8&list=PLD8gywOEY4HauPWPfH0pJPIYUWqi0Gg10) &mdash; YouTube video series by Andres LÃ¶h. A solid, step-by-step progression from the basics to higher-level concepts, with some good tips thrown in.

### Honorable Mentions

- [Typeclassopedia](https://wiki.haskell.org/Typeclassopedia) &mdash; A bit verbose and math-y, but worth giving it a skim, if only to get glimpse at the host of utility functions out there.
- [Maybe Haskell](https://github.com/thoughtbot/maybe_haskell) &mdash; Goes over Functors, Applicatives, and Monads through the lens of Maybe. Short and sweet, with solid examples and easy to follow prose.
